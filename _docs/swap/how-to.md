---
title: How to
subtitle:
tags: []
category: Swap Provider
layout: doc_sw
---

#### Sections in this article
{:.no_toc}
* TOC
{:toc}

In order to become a swap provider in the Ledger Live ecosystem, you must submit your API following Ledger’s specifications. We will guide you through the requirements and the modifications you will need to apply to your API before sending it to us. 

This diagram shows what is needed from the provider’s side in order to interact with Ledger Live.

![How to diagram](../images/how-to.png "How to diagram")

## Endpoints

In order to communicate with Ledger’s back-end, you have to give us the mapping of the endpoints we need. <br> 
As you can see on the diagram above, there are 4 main endpoints needed for the swap: 
- To get the list of tradable pairs: `/providers`.
- To query a rate: `/rate`.
- To perform a swap (with the Payload/signature required by the nano): `/swap`.
- To query a swap status: `/status`. <br>
Additionally, we also need a way to know if a user will be able to trade given his IP (see **IP address checking** below).

### Data mapping

Here are the details about each needed endpoint. Note that they are all pretty standard, except for **POST /swap**, which needs to follow our exact structure (see [Swap Endpoint](#swap-endpoint) section below for more details). 

As an example, you can refer to  [Changelly’s API](https://github.com/changelly/api-changelly), a provider that is already integrated to Ledger Live. <br> 
The following swagger page can be found [here](https://swap-stg.ledger.com/docs/index.html?url=/docs/docs.yaml#/v3).

<iframe title="Endpoint mapping" src="https://swap-stg.ledger.com/docs/index.html?url=/docs/docs.yaml#/" width="100%" height="400" style="border:1px solid black;"></iframe>

Some requirements about the **/rate** endpoint:
- The quote must work without user auth.
- The quote must be valid long enough (at least a few minutes).

The **/swap** endpoint is trickier, and needs to follow this structure, as well as some requirements:
- Signed prop. format for the user nano.
- Should check the auth bearer token.<br>
See [Swap Endpoint](#swap-endpoint) section below for more details.

**IP address checking** <br>
You should provide a way to check if the user's geolocation is allowed to do coin swap, given the IP of the user.<br>
Our back-end can adapt to how you decide to do this, but we recommend you use a dedicated endpoint. Our back-end will send the user’s IP address to that endpoint, without logging it. In response, your endpoint should tell us if the trade is accepted or rejected.


### Swap endpoint

#### Protobuf message (payload)

Your Protobuf message should have the following structure: 

```json
syntax = "proto3";
package ledger_swap;

message NewTransactionResponse {
    string    payin_address = 1;
    string    payin_extra_id = 2;
    string    refund_address = 3;
    string    refund_extra_id = 4;
    string    payout_address = 5;
    string    payout_extra_id = 6;
    string    currency_from = 7;
    string    currency_to = 8;
    bytes     amount_to_provider = 9;
    bytes     amount_to_wallet = 10;
    string    device_transaction_id = 11; // nonce
}
```

Explanation of each fields: 
- `payin_address`: provider address to receive payment
- `payin_extra_id`: eventual memo for the payment (stellar payment, for instance)
- `refund_address`: client address to receive back the payment funds in case the provider is not able to execute the swap for some unpredictable reasons
- `refund_extra_id`: eventual memo for the payment (stellar payment, for instance)
- `payout_address`: client address to receive the money resulting from a successful swap
- `payout_extra_id`: eventual memo for the payment (stellar payment, for instance)
- `currency_from`: currency that the client wants to swap
- `currency_to`: currency that the client wants to receive from his swap
- `amount_to_provider`: amount of `currency_from` that the provider expects to receive from client
- `amount_to_wallet`: amount of `currency_to` that the provider agrees to send to the client in exchange from `amount_to_provider`. This amount must also include the network fees that the provider will pay to send the crypto to the user.
- `device_transaction_id`: swap transaction nonce provided by client at initialization

Amounts must be in the lowest unit in the field `coefficient` with its `exponent`.<br>
Example:
- 1 **BTC** would be `0x5F5E100` (100000000 in hexadecimal). The smallest unit is a **satoshi** which is `10^-8` **BTC**.<br> 
So multiply 1 **BTC** by `10^8` → `0x5F5E100`.
- 2 **ETH** would be `0x1BC16D674EC80000` (or 2000000000000000000). The smallest unit is a **wei** which is `10^-18` **ETH**.<br> 
So multiply 2 **ETH** by `10^18` → `0x1BC16D674EC80000`. 


#### New field: nonce

The following JSON field should be added to your API:

- In the JSON request for a swap, a new field `nonce` for the 32 bytes nonce which is generated by the hardware wallet to avoid replay attacks. It will be base 64 URL encoded by the Ledger Live.

```json
{"from": "btc", 
 "to": "eth",
 "address": "0xee*******5E3DFc214",
 "amountFrom": "1",
 "rateId": "f3dd48106a63b*********b7ab5413d32c7b96301a7e82",
 "refundAddress": "1Bvjij5653y9****BGPuQBPzTZpb",
 "nonce": "r5mP6AbVNua5FsNw-oFD4tFJUrXQA1tYwMsmrg4Ft2Q"}
 ```

#### New field: providerSig

The following JSON field should be added to your API:

In the JSON response, a new field `providerSig` with a JSON Web Signature (JWS) in compact form within:
- `providerSig.header.alg` - the algorithm used for the signature: “ES256”.
- `proverSig.header.kid` - an identifier for the public key used: “provider_name-2020“.
- `providerSig.payload` - base 64 URL of the binary serialized protobuf message.NewTransactionResponse.
- `providerSig.signature` - base 64 URL of the ES256 signature of providerSig.payload. More details in the [JWS signature](#jws-signature) and [Protobuf message (payload)](#protobuf-message-payload) sections. 

##### JWS signature

The JWS signature should have to following structure:
```json
"providerSig": {
"header": {
"alg": "ES256",
"kid": "provider_name-2020"
},
"payload": "Cg9oZWxsb0BsZWRnZXIuZnISA0JUQyIiMUExelAxZVA1UUdlZmkyRE1QVGZUTDVTTG12N0Rpd
mZOYSoDRVVSMgYKAgT_EAJCIK-Zj-gG1TbmuRbDcPqBQ-LRSVK10ANbWMDLJq4OBbdk",
"signature": "ak57fQ3nX-cslMjxZijdNylQbsHDE8LI73ap71O1j8k91aFiqtdaXJltyq0NJnmRwmL_yNF
N84JIORpuRScqEg"
}
```

The same JSW signature in compact form:
```json
"providerSig": ".Cg9oZWxsb0BsZWRnZXIuZnISA0JUQyIiMUExelAxZVA1UUdlZmkyRE1QVGZUTDVTTG12
N0RpdmZOYSoDRVVSMgYKAgT_EAJCIK-Zj-gG1TbmuRbDcPqBQ-LRSVK10ANbWMDLJq4OB
bdk.xTq9CYn38DdxRfocnOJpjRWv4eD-_gVEMNoz_7nHVIFRhlLZOQyk04Q6zHHucgK3S
s3IG1NOjw5aC9weCF5aRg"
```

## KYC & Registration

You will need to develop an iframe for the Login, which will also trigger the KYC when needed. <br>
TBD: This section will be updated once we know if that iframe will go in a live app, and how it will notify the Ledger Live back-end that the Login/KYC is completed. 
